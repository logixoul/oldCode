template<class T,class FetchFunc>
Array2D<T> separableConvolve(Array2D<T> src, vector<float>& kernel) {
	int ksize = kernel.size();
	int r = ksize / 2;
	
	T zero=::zero<T>();
	Array2D<T> dst1(src.w, src.h);
	Array2D<T> dst2(src.w, src.h);
	
	int w = src.w, h = src.h;
	
	// vertical

	for(int y = 0; y < h; y++)
	{
		auto blurVert = [&](int x0, int x1) {
			// guard against w<r
			x0 = max(x0, 0);
			x1 = min(x1, w);

			for(int x = x0; x < x1; x++)
			{
				T sum = zero;
				for(int xadd = -r; xadd <= r; xadd++)
				{
					sum += kernel[xadd + r] * (FetchFunc::fetch<T>(src, x + xadd, y));
				}
				dst1(x, y) = sum;
			}
		};

		blurVert(0, r);
		blurVert(w-r, w);
		for(int x = r; x < w-r; x++)
		{
			T sum = zero;
			int xadd = -r;
			T* src_p = &src(x + xadd, y);
			float* kernel_begin = &kernel[0];
			float* kernel_end = &kernel[r + r + 1] + 1;
			float* kernel_p = kernel_begin;
			for(; kernel_p != kernel_end; xadd++)
			{
				sum += *kernel_p * *src_p;
				kernel_p++;
				src_p++;
			}
			dst1(x, y) = sum;
		}
	}
	
	// horizontal
	for(int x = 0; x < w; x++)
	{
		auto blurHorz = [&](int y0, int y1) {
			// guard against h<r
			y0 = max(y0, 0);
			y1 = min(y1, h);
			for(int y = y0; y < y1; y++)
			{
				T sum = zero;
				for(int yadd = -r; yadd <= r; yadd++)
				{
					sum += kernel[yadd + r] * FetchFunc::fetch<T>(dst1, x, y + yadd);
				}
				dst2(x, y) = sum;
			}
		};

		blurHorz(0, r);
		blurHorz(h-r, h);
		for(int y = r; y < h-r; y++)
		{
			T sum = zero;
			for(int yadd = -r; yadd <= r; yadd++)
			{
				sum += kernel[yadd + r] * dst1(x, y + yadd);
			}
			dst2(x, y) = sum;
		}
	}
	return dst2;
}